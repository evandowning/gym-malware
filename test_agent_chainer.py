import sys
import argparse
import numpy as np
from gym_malware.envs.utils import interface, pefeatures
from gym_malware.envs.controls import manipulate2 as manipulate

from gym_malware import sha256_train, sha256_holdout, MAXTURNS
from collections import defaultdict

from keras.models import load_model

ACTION_LOOKUP = {i: act for i, act in enumerate(manipulate.ACTION_TABLE.keys())}

from train_agent_chainer import create_acer_agent
import gym

import hashlib

def evaluate( action_function ):
    success=[]
    misclassified = []
    for sha256 in sha256_holdout:
        sys.stdout.write('Original binary: {0}\n'.format(sha256))
        success_dict = defaultdict(list)
        bytez = interface.fetch_file(sha256)
        label = interface.get_label_local(bytez)
        if label == 0.0:
            misclassified.append(sha256)
            continue # already misclassified, move along
        for i in range(MAXTURNS):
            action = action_function( bytez )

            sys.stdout.write('Iteration {0}/{1}\n'.format(i+1,MAXTURNS))

            m = hashlib.sha256()
            m.update(bytez)

            sys.stdout.write('    Original has value: {0}\n'.format(m.hexdigest()))
            sys.stdout.write('    Modifying binary via action: {0}\n'.format(action))

            success_dict[sha256].append(action)
            bytez = manipulate.modify_without_breaking( bytez, [action] )
            new_label = interface.get_label_local( bytez )
            if new_label == 0.0:
                success.append(success_dict)
                break
    return success, misclassified # evasion accuracy is len(success) / len(sha256_holdout)

import os
def get_latest_model_from(basedir):
    dirs = os.listdir(basedir)
    lastmodel = -1
    for d in dirs:
        d_int = d.split('_')[0]
        try:
            if int(d_int) > lastmodel:
                lastmodel = int(d_int)
                lastmodel_name = d
        except ValueError:
            continue

    assert lastmodel >= 0, "No saved models!"
    return os.path.join(basedir, str(lastmodel_name))


def _main():
    prog = "test_agent_chainer"
    descr = "Tests chained agent against random sampling"
    parser = argparse.ArgumentParser(prog=prog, description=descr)
    parser.add_argument("--ember-model", type=str, help="Pretrained ember model", default=None, required=False)
    args = parser.parse_args()

    # If no ember model supplied, use model supplied in repo
    if args.ember_model is not None:
        import lightgbm as lgb
        from gym_malware.envs.utils.emberfeatures import PEFeatureExtractor
        interface.feature_extractor = PEFeatureExtractor(1) # Just use version 1 features
        lgbm_model = lgb.Booster(model_file=args.ember_model)
        interface.local_model = lgbm_model
        interface.model_type = 'ember'

    # baseline: choose actions at random
    random_action = lambda bytez: np.random.choice( list(manipulate.ACTION_TABLE.keys()) )
    random_success, misclassified = evaluate( random_action )
    total = len(sha256_holdout) - len(misclassified) # don't count misclassified towards success

    ENV_NAME = 'malware-test-v0' 
    env = gym.make(ENV_NAME)

    fe = pefeatures.PEFeatureExtractor()
    def agent_policy(agent):
        def f(bytez):
            # first, get features from bytez
            feats = fe.extract( bytez )
            action_index = agent.act( feats ) 
            return ACTION_LOOKUP[ action_index ]
        return f

    agent = create_acer_agent(env)
    # pull latest stored model
    last_model_dir = get_latest_model_from('models/acer_chainer')
    agent.load( last_model_dir )
    success, _ = evaluate( agent_policy(agent) )

    agent_score = create_acer_agent(env)
    # pull latest stored model
    last_model_dir = get_latest_model_from('models/acer_score_chainer')
    agent_score.load( last_model_dir )
    score_success, _ = evaluate( agent_policy(agent) )

    sys.stdout.write('Success rate of random chance: {0}\n'.format( len(random_success) / total ))
    sys.stdout.write('Success rate (black box): {0}\n'.format( len(success) / total ) )
    sys.stdout.write('Success rate (score): {0}\n'.format( len(score_success) / total ) )

if __name__ == '__main__':
    _main()
